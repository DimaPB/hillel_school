# Задача 1
# 1) Напишіть 10 тестів(можна що б просто повертали Тру(щоб проходили)) імена тестів повині йти підряд
# test_1, test_2 ... . Повішайти на них три декоратора old, main, new.
# кожен декоратор повинен бути на 3 функціях
# на одній з функцій повино бути повішано два декоратора old i main.
# додайти їх в python.ini що б були правильні виводи
#
# Зробіть такі прогони
# 1) всі тексти де немає лейби old
# 2) тест де пересікаються old i main.
# 3) тести з маркерами main, new
# З домашкою здайте скріншоти з прогонами, на скріншотах повино бути
# видно який саме тест прогнався(використовуйте прапор verbose).
#
# Задача 2
# Візьміть задачу з минулого уроку(
# 3) зробіть функцію як ми робили з додаванням тільки замість двох чисел зробіть три
# числа і протестуйте її всіма
# трьома методами
# ) модернізуйте її так що кожний раз коли ми її запускаємо те що ми туди передаєм та результат повинно записуватись в файл log.txt
# Зверніть увагу на те що в файл повинно дозаписуватись, а не затератись.
# Уявіть що ця функція являється легасі кодом і ви її не можете змінювати,
# тому потрібно використовувати декоратор. Я хотів би бачити таку реалізацію в домашці три функції:
# функція з минулого уроку
# функція що записую текст
# і декоратор


# def write_logs(func):
#     def file_change():
#         with open("log.txt", "a") as file:
#             file.write("\n")
#             file.write(result)


def write_logs(func):
    def wrapper(*args):
        result = func(*args)
        arguments = args
        with open("log.txt", 'a') as file:
            file.write(f"Result: {str(result)} \n")
            file.write(f"Arguments: {str(arguments)} \n")
        return result
    return wrapper


@write_logs
def add_tree_numbers(number_1: int | float, number_2: int | float, number_3: int | float) -> int | float:
    result = number_1 + number_2 + number_3
    return result


result = add_tree_numbers(1, 2, 3)
print(result)




